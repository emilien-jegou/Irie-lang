---- Basic functions
-- g y = y + 2
-- f x = x + g x
-- l x = if x.p then x.q else x.q
-- r g = r (g 1) -- recursive principal type

--fib x : Int -> Int = if x < 1 then x else fib (x-1) + fib (x-2)
--fib x = if x < 1 then x else fib (x-1) + fib (x-2)

-- Arrays basic
--l = 3 2 7 -- : Array 3 Int
--z = l ! 1

--Array : [Int] -> Set -> Set
--Array shape ty =
-- | PrimArray [ty]
-- | Generate (Int->ty)
-- | Reversed (Array ty)
-- | Tabulate ((Array Int [len shape]) -> ty)

--shapeOf :: { n ; X } : Array n X -> [Int]
--shapeOf@{n} = n

-- a = PrimArray @ (3 2 7)
-- x = primLen (3 2 2)

plus a b = a + b
primFoldrN f x v n = if n < 1 then f (x!0) v else f (x!n) (primFoldrN f x v (n-1))
xd = primFoldrN plus (2 3 3) 0 3

--mean : [Int] -> Int
--mean a = insert plus a / (len a)

--id x   = x
--idot n = Generate @ id n
--t = idot (2 3)

-- Higher rank
-- auto i = (i i) 3
-- id x = x
--g = auto id

---- Records
-- x = { b=3 ; h=4 }
-- c = x.b
-- p x = if x.p then x.q else x.q -- : {p:Bool , q:a} -> a

---- Sums
-- num = int @ 3 -- : | int Int
-- f x = case x | int @ n => n

---- Classic Dependent vector
--data Vec v : Nat -> Set where
--  empty  : Vec v 0
--  append : v -> Vec v {n} -> Vec v (n + 1)

--Bool = True | False -- 2 labels (label =? type)
--not x = x ? { True => False ; False => True }

--Op2 t = (->) % [t t t]
--(+) : Op2 Nat
