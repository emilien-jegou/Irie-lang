--externVarArg printf : CharPtr -> Int
--import imports/lambda
--import imports/basic
--import imports/mixfix
--import imports/records
--import imports/impredicative
--import imports/array
--import imports/church
--import imports/fin
--import imports/dependents
--import imports/printf
--import imports/subtype

--- BigInt =
---   | One : Int -> BigInt
---   | Two : Int -> (Int -> BigInt)
--- 
--- --BigAdd a b = case a of
--- --  | One va => case b of
--- --    | One vb => (One (plus va vb)) -- ifThenE 0  (Two (zext o) val)
--- 
--- Id x = case x of | One vx => One (putNumber (plus 99 vx))
--- PrintInt a = case a of | One va => putNumber va
--- 
--- --main = PrintInt (One 32)
--- main = PrintInt (Id (One 32))

List =
  | Nil : List
  | Cons : Int -> (List -> List)

PrintList l = case l of
  | Nil => 0
  | Cons i l' => plus (putNumber i) (PrintList l')

Inc l = case l of
  | Nil => Nil
  | Cons i l' => Cons (plus 1 i) (Inc l')

main = PrintList (Inc (Cons 12 (Cons 98 Nil)))

--main = PrintList (Inc (Cons 12 (Cons 43 Nil)))

-- mk generator (fn and state)
-- 0. st = gen ; ST
-- 1. call gen
-- 2. step: calc to depth 1 then call next fn
-- 3. maybe fn wants more stream => 
-- 4. end of st: call gen once more (maybe unwind stack)

-- [12,43] ; [@Inc,PrintList] => [13,43] ; [Inc,@PrintList] => [43] ; [@Inc,PrintList] ..

-- Right | Left fold

-- * ST { { STAlts } ; { STAlts } ; [ { STAlts ; l1 } , { STAlts ; l2 } ] }
-- * Stream = { Generator ; ST ; Label }

-- Push | Pull ?!
-- Pull => how to unwind stack ? doesn't play well with stack machine
-- Push n? => | callback to request more .. push to buffer
-- * strict to depth n

-- 1. push to depth n                   | noop
-- 2. depth n intermediaries            | when to stop ?
-- 3.a. fold depth n                    | has to be left-assoc
-- 3.b. request more                    | more stack for callback
-- 4. push more                         | restart chain

-- strict n
-- | unwind stack | lazy thunk (morestack)
-- Tree ?
-- Generator ?
-- Either label | generator

-- ST     = STEnd | STStrict | STCont [Fns] | STAlts [Fns] | STZip [Stream]
-- Stream = { st : [ST] , ix : Int , lNext : label }
-- Start: call st[-1] { st ; count-1 ; count ; lNext } l0
-- * stend    => terminate
-- * stStrict => recurse over label, cont st
-- * normal   => do 1 label, cont st
-- * pull     => modify the stream inplace
