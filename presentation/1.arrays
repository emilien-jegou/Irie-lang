flexible typevariables
*   tuples subsume arrays
*   [a] can supersume eg. (Int , String)
    *     allows us to generalize all 'list' functions (rather than hacking lens as a secondary list system atop algebraic data: note. that lenses get,set, and traversals are exactly equivalent to list operations. Prisms are interesting however - they let us deal with lenses that operate over list-like algebraic data

-- normal zip
zip    : [a] -> [c] -> [(a,c)]

-- join at rank 1 (sometimes called `stitch`)
(,)@1  : [a] -> [a] -> [[a],[a]]

-- normal zipWith
zipWith : (a->b->c) -> [a] -> [b] -> [c]
-- we notice a pattern: repeat, map, zipWith, zipWith3 ..
-- defining zipWith as a special case of this (@$) function
-- requires arity-generic function.

-- Perhaps even more interestingly, we also have
zipWith f = (fold1 f) @_1 -- fold f at rank -1


If `a` is a flexible type variable, then (,)@1 actually directly subsumes zip
? concretely though.. for codegen all polytypes must be resolved to monotypes, how?
= [a] is necessarily a dependent type

So we are left with `Prisms`, having obsoleted the rest of lens

Lens is strong, especially without hacks (template-haskell + emulating subtyping)

----------------
-- Genericity --
----------------
Some functions are doubly-generic, as repeat..zipWithN

-----------
-- Frank --
-----------
