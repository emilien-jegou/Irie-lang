module CmdLine (CmdLine(..), parseCmdLine, defaultCmdLine)
where

import Options.Applicative
import Data.Semigroup ((<>))

data CmdLine = CmdLine
  { emitSourceFile :: Bool
  , emitParseTree  :: Bool
  , emitParseCore  :: Bool
  , emitCore       :: Bool
  , emitStg        :: Bool
  , emitLlvm       :: Bool

  , noPrelude      :: Bool

  , jit            :: Bool
  , optlevel       :: Word
  , files          :: [String]
  } deriving (Show)

defaultCmdLine = CmdLine False False False False False False False False 0 []

cmdLineDecls :: Parser CmdLine
cmdLineDecls = CmdLine
  <$> switch (long "emit-sourceFile"
          <> short 'S'
          <> help "Output program source")
  <*> switch (long "emit-parsetree"
          <> short 'p'
          <> help "Output program parse tree")
  <*> switch (long "emit-parse-core"
          <> short 'P'
          <> help "Output core as generated by toCore function")
  <*> switch (long "emit-core"
          <> short 'c'
          <> help "Output core after type-judgements")
  <*> switch (long "emit-stg"
          <> short 's'
          <> help "Output stg")
  <*> switch (long "show-llvm"
          <> short 'l'
          <> help "Output llvm disassembly")

  <*> switch (long "no-prelude"
          <> short 'n'
          <> help "don't import prelude implicitly")

  <*> switch (long "jit"
          <> short 'j'
          <> help "execute program in jit")
  <*> option auto (short 'O'
               <> help "optimization level = 0|1|2|3"
               <> value 0)
  <*> many (argument str (metavar "FILE"))

cmdLineInfo = info (cmdLineDecls <**> helper) description
  where description = fullDesc
                   <> progDesc "lfvm-stg compiler"
                   <> header "lfvm"

parseCmdLine :: IO CmdLine
parseCmdLine = execParser cmdLineInfo
