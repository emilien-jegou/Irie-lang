-- module Prim -- (sizeOfInt : #!Int 32)
-- #! will directly parse an llvm type or llvm instruction

type Int             = #!Int 32
type Nat = Int -- difference is we use unsigned instructions
type CharPtr = #!CharPtr

-- all float types use the same llvm instructions
-- type Half      = #!Half
-- type Float     = #!Float -- broken for some reason
type Double    = #!Double
-- type FP128     = #!FP128        -- 112 bit mantissa
-- type PPC_FP128 = #!PPC_FP128 -- two 64-bits
-- Frac = Half | Float | Double | FP128 | PPC_FP128

infix 6 +
infix 7 *
class Num where
  (+)  : Num->Num->Num
  (-)  : Num->Num->Num
--  (*)  : a->a->a
----(//) : a->a->a
----(/?) : a->a->a
----(==) : a->a->a
--  --(/)  : Int -> Int -> Real = \x y -> (#!fptoui x) // (#!fptoui y)

instance Num Int where
  (+)  : Int->Int->Int = #!add
  (-)  : Int->Int->Int = #!sub
--(*)  : Int->Int->Int = #!mul
--(//) : Int->Int->Int = #!sdiv
--(/?) : Int->Int->Int = #!srem
--(==) : Int->Int->Int = #!icmp

instance Num Double where
  (+)  : Double->Double->Double = #!fadd
  (-)  : Double->Double->Double = #!fsub
--  (*)  : Float->Float->Float = #!fmul
--(//) : Int->Int->Int = #!fdiv
--(/?) : a->a->a = #!frem
--(==) : a->a->a = #!fcmp

-- unsigned overloads for Nat
--(//) : Nat -> Nat -> Nat = #!udiv
--(/?) : Nat -> Nat -> Nat = #!urem

--class Frac where
--  type ROp2 = Real -> Real -> Real
--  (+) : ROp2 = #!fadd
--  (-) : ROp2 = #!fsub
--  (*) : ROp2 = #!fmul
--  (/) : ROp2 = #!fdiv
--  (/?): ROp2 = #!frem
--  (==): ROp2 = #!fcmp

-- TODO tuples
----------------------
-- Array primitives --
----------------------
--(.) : n*e -> i -> e = \arr i -> #!atIndex arr i
--(len) : n*e -> Nat = n

---- ! requires type functions
--type Ptr e           = #!Ptr e
--type (n:Nat) * eType = #!Array n eType
-- #!Struct tyList -- takes a tuple of types.. scary

-- C extern functions --
extern puts : (#!CharPtr) -> Int
externVarArg printf : (#!CharPtr) -> Int
putNumber n = printf "%d\n" n
putDouble f = printf "%f\n" f
