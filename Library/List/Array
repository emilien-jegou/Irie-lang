type Any  -- union polytype of all types of any rank in scope
type Void -- empty type
type Arrow r = Stack (->) r
-- generalized case deconstruction: a value and function to (maybe) run
caseMatch : forall e r :: e -> (e -> Arrow r)

-----------
-- Stack --
-----------
class Stack eType where
  Cons : eType -> Stack -> Stack
data Stack eType nil
 = Cons eType Stack
 | Nil  nil

-----------
-- Array --
-----------
-- Array: Anything indexable with a fixed length, incl tuples nth term functions
-- even tuples are Arrays, when eType is a flexible type variable (or Any)
alias (*) = Array -- infix version
class Array (count:Nat) eType where
  -- Array class supersumes tuples,records and basic arrays
  count     : Array len eType -> Nat = len
  (!)       : Array len eType -> Nat {(<len)} -> eType
  buildI    : count=Nat -> (Nat->eType) -> Array count eType
  -- build can construct elements depending on itself
  buildIFix : forall count=Nat eType this=(Array count eType) :: (Nat->this->eType) -> this
--  (!=)   : Array len eType -> Nat {(<len)} -> eType -> Array len eType

-- LLVM Array --
instance (Array c e) (#! Array c e) where
  (!)  arr idx = #! extractVal arr idx
-- Tuple --
instance (Array c e) (forall eTy<=e tyList=[eTy] :: #!Tuple count tyList) where
  (!) : Tuple len tyList -> (n : Nat {(<len)}) ->  tyList!n
  (!) arr idx = #! extractVal arr idx

--------------
-- Abstract --
--------------
class AbstractArray eType where
  buildG : forall a :: count=Nat -> (forall b:: (a->b->b)->b->b) -> Array count a
  buildI : count=Nat -> (Nat -> eType) -> Array count eType

----------
-- List --
----------
-- list class: how to handle abstract lists, fold-build, conversion between list instances
class List eType where
  pattern (++) : List eType -> List eType -> (List eType -> List eType -> Any)

-- Array functions
(++) : Array al  eType -> Array bl eType -> Array (al + bl) eType

-- List functions
(!!) : Array len e -> Int -> e = \arr idx => arr ! (if idx<0 then len+idx else idx)
