-- module Prim -- (sizeOfInt : #!Int 32)
-- #! will directly parse an llvm type or llvm instruction

type Int             = #!Int 32
type Nat = Int -- difference is we use unsigned instructions
type CharPtr = #!CharPtr

-- all float types use the same llvm instructions
-- type Half      = #!Half
type Float     = #!Float
type Double    = #!Double
-- type FP128     = #!FP128        -- 112 bit mantissa
-- type PPC_FP128 = #!PPC_FP128 -- two 64-bits
-- Frac = Half | Float | Double | FP128 | PPC_FP128

infix 6 +
infix 7 *
class Num a where
  (+)  : a->a->a
  (-)  : a->a->a
  (*)  : a->a->a
  (//) : a->a->a
  (/?) : a->a->a
  (==) : a->a->a
  --(/)  : Int -> Int -> Real = \x y -> (#!fptoui x) // (#!fptoui y)

instance Num Int where
  (+)  : a->a->a = #!add
  (-)  : a->a->a = #!sub
  (*)  : a->a->a = #!mul
  (//) : a->a->a = #!sdiv
  (/?) : a->a->a = #!srem
  (==) : a->a->a = #!icmp

instance Num Float where
  (+)  : a->a->a = #!fadd
  (-)  : a->a->a = #!fsub
  (*)  : a->a->a = #!fmul
  (//) : a->a->a = #!fdiv
  (/?) : a->a->a = #!frem
  (==) : a->a->a = #!fcmp

-- unsigned overloads for Nat
--(//) : Nat -> Nat -> Nat = #!udiv
--(/?) : Nat -> Nat -> Nat = #!urem

--class Frac where
--  type ROp2 = Real -> Real -> Real
--  (+) : ROp2 = #!fadd
--  (-) : ROp2 = #!fsub
--  (*) : ROp2 = #!fmul
--  (/) : ROp2 = #!fdiv
--  (/?): ROp2 = #!frem
--  (==): ROp2 = #!fcmp

-- TODO tuples
----------------------
-- Array primitives --
----------------------
--(.) : n*e -> i -> e = \arr i -> #!atIndex arr i
--(len) : n*e -> Nat = n

---- ! requires type functions
--type Ptr e           = #!Ptr e
--type (n:Nat) * eType = #!Array n eType
-- #!Struct tyList -- takes a tuple of types.. scary

-- C extern functions --
extern puts : (#!CharPtr) -> Int
externVarArg printf : (#!CharPtr) -> Int
--putNumber n = printf "%d\n" n
