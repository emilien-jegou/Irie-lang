--List =
--  | Nil : List
--  | Cons : Int -> (List -> List)
--
--  L a =
--    | Nil : L
--    | Cons : Arrow a (Arrow L L)
--  
--  --pure x v = { ret = x }
--  ----pOK ps = ps . cok . set 1
--  
--  _>>_ = \f x a => x (f a)
--  _<_  = \f x => f x
--  
--  z = add < 5
--  
--  printList l = case l of
--    Nil => 0
--    Cons i ll => add (putNumber i) (printList ll)
--  
--  Inc l = case l of
--    Nil => Nil
--    Cons i ll => Cons (add 1 i) (Inc ll)
--  
--  scanSum n l = ifThenElse (le n 0) l (scanSum (sub n 1) (Cons n l))

fromMaybe l = case l of 
  Maybe b => b
  Nothing => 0

null l = case l of
  Cons x xs => 0
  Nil       => 1

--span p xs = case xs of
--  Nil => { left = xs , right = xs }
--  Cons x xs2 => if p x
--    then let { left = ys , right = zs } = span p xs2 in (Cons x ys , zs)
--    else { left = Nil , right = xs }

foldr f s l = case l of
  Cons x xs => f x (foldr f s xs)
  Nil       => s

foldl f s l = case l of
  Cons x xs => foldl f (f s x) xs
  Nil => s
 
c a b = Cons a b
append front back = foldr c back front
concat = foldr (append) Nil
-- n = Cons '\n' Nil
consF f x xs = Cons (f x) xs
mapFold f l = foldr (consF f) Nil l
concatMap f xs = foldr (\x b => foldr c b (f x)) Nil xs
unlines ls = concat (mapFold (\l => append l (c '\n' Nil)) ls)
-- unlines2 = concatMap (\l => append l (Cons '\n' Nil))

-- --concatMap f xs = build \c n => foldr (\x b => foldr c b (f x)) n xs
-- -- concatMap :: (a -> [b]) -> [a] -> [b]

-- go sep l = case l of
--   | Nil => Nil
--   | Cons x xs => Cons sep (Cons x xs)
-- 
-- intersperse sep l = case l of
--   | Nil => Nil
--   | Cons x xs => Cons x (go sep xs)

--level a = let px x = plus a x in plus 3

--bad = (scanSum 5 Nil) >> printList
--identity x = x

--one = Cons 12 Nil
--two = Inc one
--main = printList one

--two = Cons 12 ( Cons 98 Nil)
--main = printList (Inc (scanSum 3 Nil))
