## Top Priority
  * languageDocumentation.md
  * Type aliases
  * polymorphic subsumption
  * functor modules/records; patterns in records (?) `(a , b) = (1 , 3)` opened vs closed
  * reconcile first order foldl and foldr for fusion; ListFn => FoldL fl | FoldR fr | Array fl fr (| Ix)
  * toCStruct / fromCStruct / [ptr] : A -> CStruct
  * globalresolver should discard names from the module its recompiling (esp. to avoid exporting now deleted names)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * type intersection vs type union functions (intersection should indicate if noop)
  * check escaped | leaked | dead vars are updated at right time through let-nests & mutuals
  * switch back to deBruijn mus
## Top
  * show + repl typecase to print JIT results
  * provide Vector alternative for ADTs when names sequential (they frequently are) [n..m]
  * make new datatypes: growable vector and hashmap + vector 'StrIntName'
  * let-bound functions origin `f.l` + f knows owned let-binds (what if in a record ?)
  * Linear typing
  * make a prettyprinter Doc for error messages
## Parse
  * don't allow mixing tabs and spaces
  * Pattern guards
  * List comprehensions
  * rewrite patterns2TT & top level patterns; maybe exploit functor modules?
## Types
  * handle field name collisions (THFieldCollision)
  * Dependent normalisation & Staging (compile recursive defs when normalising)
  * Place the forall. in negative positions correctly
  * first class polymorphism
  * mergetyhead should indicate if merge was a noop (so bisub knows it has already seen that input)
## Error messages
  * Warn nonsense type joins
  * lone mfWords that aren't ambig-binds should error (also non-explicit partial apps like f = 3 <)
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
## Simplifier
  * constructor specialisation
  * case-of-case
  * static argument transformation
  * tycon promotion (promote single field /labels to value)
  * + 0 => identity
  * normalize fields/labels for codegen

## Unimportant
  * optimise checking for recursive wrappers
  * check let-rec / mutuals
  * Repeat not-in-scope errors (replace NotInScope with PoisonExpr on first fail?)
  * make work module import loops
  * language server
  * optimize cached modules
  * sh syntax `ls -lr` => `ls { l=True , r=True }`
  * engineer GlobalResolver to work concurrently
  * when recompiling cached modules, figure out what changed
  * prefetch memory | loop unrolling
  * exploit the cpu carry flag ?
