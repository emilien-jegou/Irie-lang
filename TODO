# !!
  * Dependent types
  * Typeclass instantiation

# expr2Core
  * Let
  * tuples (anon product types)
  * records
  * array prims
  * use a fromString function for literals
  * inline primitives

  * precedence (parser doesn't have all infix decls)
  * primitive type operators (| & ->)
  * patterns, nested patterns, matches2Case
  * TyRigid could be polytype
  * multiparam typeclasses
  * default typeclass signatures/decls
  * fn overloads
  * list pattern matching
  * Case -> Case optimizations
  * implicit forall typevars ?
  * re-examine prim typeclasses for literals

# core2Stg
  * tyFunctions
  * polymorphic fns (boxed vs unboxed)

# typeJudge
  * resolve/instanciate polytypes (using classOverloads + default decls)

# parser
  * move all type parse logic to pExp
  * Multiple Infixes
  * custom infix decls
  * indented 'where', esp. class
  * linefolds
  * GADT style
  * rec (let-rec)
  * source locations

# Prelude / dependent types
  * fold-build
  * fusion across functions ? composition fusion
  * var-arity
  * effects
  * distribution
  * non-copyable memory (if only one inplace - could execute it last)
  * memory (sudoku example - inplace modifications undo as stack unravels)

# LFVM
  * emit extern decls for all functions

# General
  * error message clarity
  * precomipled modules

# Maybe
  * View patterns (?)
  * PAP
  * GuardedRhs
