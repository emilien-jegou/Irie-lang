# Compiler coding style
  * avoid zipwith / zip since lists can be diff lengths
## Top
  * language server
  * precompiled modules
  * Error reporting
## Parse
  * rec + subfns (case split alts) + qtt on top binds
  * Source locations
  * linefolds
  * rec
## Types
  * !! cleanup return types for sumdatas
  * Dependent normalisation
  * Calculus of effects (cf. fire triangle)
  * ifThenE bad type
  * Bicasts on lattice types (eg. extra type annotations)
## CodeGen
  * GMP
  * subtyping records/sumtypes (core idxs -> llvm idxs)

!!
Incremental compiler | unresolved externs | sigs
Modules == records (+ insane dependencies)
read type vars
finish fralloc (flat & shared data)
subtype coercions
repl & linking & print JIT results somehow
record subtyping (offset table header) # { x : i32 } <: { x : i64 }
paps | subtyped fns | primtable # Fn = & SubtypeFns & ( | FnPtr | PAp )

??
# Cata , Ana , Para , Hylo morphisms
# Polymorphism
# Wrappers
# Newtype (opt-out of subtyping)
# partial typecheck (normalization + insane dependents)
# labels/fields namespace
  * Tuple = special label-less sum-typ
  * structural subtyping vs predefined types
  * Lenses
# Effects
  * eg. In ,  Out , IO (In & Out) , State
  * Union , subtyping , effect variable
  * record subtypes non-records via special field (return)
