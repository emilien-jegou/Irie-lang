# Dependent types
# expr2Core
  * PAP
  * freevars
  * array prims + pattern matching

  * precedence (parser doesn't have all infix decls)
  * primitive type operators (| & ->)
  * patterns, nested patterns, matches2Case
  * implicit forall typevars ?
  * register subtypes before codegen in case recursive
  * TyRigid could be polytype

# Typeclass
  * Instantiation (classOverloads + defaults) (in typejudge ?)
  * default typeclass signatures/decls
  * fn overloads
  * use a fromString function for literals
  * multiparam typeclasses

# core2Stg
  * tyFunctions
  * polymorphic fns (boxed vs unboxed)

# parser
  * move all type parse logic to pExp
  * oneline let parser
  * Multiple Infixes
  * custom infix decls
  * indented 'where', esp. class
  * linefolds
  * GADT style
  * rec (let-rec)
  * source locations

# General
  * error message clarity
  * precomipled modules (also emit externs for all functions)

# Prelude / dependent types
  * fold-build
  * fusion across functions ? composition fusion
  * effects
  * distribution
  * memory (sudoku example - inplace modifications undo as stack unravels)

# Maybe
  * View patterns
  * GuardedRhs
  * Case -> Case optimizations
  * lfvm memParam may recodegen llvmArgs
  * polymorphic PAp - how are freeVars bound ?
