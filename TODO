# expr2Core
  * typeclass "trivial/class"
  * subtyping - algData are also sum polytypes (of their subtypes)
  * modules
  * dont squash bindings

  * tuples (anon product types)
  * What is allowed in a let binding ? atm it's [Decl]
  * GuardedRhs
  * more patterns
  * records
  * Case -> Case optimizations
  * precedence (parser doesn't have all infix decls)

# core2Stg
  * tyFunctions

# typeJudge
  * dependent types

# parser
  * indent as Reader
  * indented 'where', esp. class
  * linefolds
  * GADT style
  * let-rec (?)
  * source locations

# Prelude / dependent types
  * fold-build
  * fusion across functions ? composition fusion
  * var-arity
  * effects

# LFVM
  * track non-copyable data lifetime
    * data passed to multiple functions:
      if only one wants to modify it: give it ownership and execute last
    * sudoku example - inplace modifcations, that undo as stack unravels

# General
  * error message clarity
