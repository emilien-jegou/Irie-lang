## Top Priority
  * languageDocumentation.md
  * User declared types and non-trivial type annotations
  * normalize fields/labels for codegen
  * functor modules/records; patterns in records (?) `(a , b) = (1 , 3)` opened vs closed (qualified names) records , mixfixes
  * reconcile first order foldl and foldr for fusion; ListFn => FoldL fl | FoldR fr | Array fl fr (| Indexable)
  * toCStruct : A -> CStruct
  * Reduce TVars required and Bisub vector size
  * check escapedVars are updated at right time through let-nests & mutuals
## Top
  * show + repl typecase to print JIT results
  * provide Vector alternative for Cons | THProduct when names sequential (frequent) [n..m]
  * make new datatypes: growable vector and hashmap + vector 'StrIntName'
## Parse
  * recognize let|rec and norecurse
  * don't allow mixing tabs and spaces
  * safer use of [n..] numbered args
  * Pattern guards
  * List comprehensions
  * make more robust patterns2TT & patBind (top level patterns) maybe exploit functor modules?
## Types
  * rm THVar in favor of THVars
  * handle field name collisions (THFieldCollision)
  * cache escaped vars in THTyCon (add a bitset)
  * Dependent normalisation & Staging (compile recursive defs when normalising)
  * typevars with bounds (a->b) & (c->d) need to be flattened and merged for co-occurence analysis (a&c -> b&d)
  * simplify type; imports.basic.twice f x = f (f x)
  * Careful mergeing mu types; µx. may contain other µx.!
  * need to generalise (place the forall.) in polymorphic subexpressions correctly
  * Perhaps insert Mus during finalisation
## Error messages
  * Warn nonsense type joins
  * lone mfWords that aren't ambig-binds should error (also things like f = 3 <)
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
## Simplifier
  * constructor specialisation
  * case-of-case
  * static argument transformation
## Codegen
  * promote single field records to field value (esp. if avoids pointer indirection)

## Unimportant
  * Don't repeat not-in-scope errors (replace NotInScope with PoisonExpr on first fail?)
  * make work module import loops
  * language server
  * optimize cached modules
  * sh syntax `ls -lr` => `ls { l=True , r=True }`
