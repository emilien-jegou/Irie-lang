# !!
  * Dependent types
  * Typeclass instantiation

# expr2Core
  * Let
  * array prims
  * modules
  * tuples (anon product types)

  * TyRigid could be polytype
  * multiparam typeclasses
  * default typeclass signatures/decls
  * fn overloads
  * records
  * more patterns
  * Case -> Case optimizations
  * precedence (parser doesn't have all infix decls)
  * risky implicit forall typevars ?

# core2Stg
  * tyFunctions
  * polymorphic fns (boxed vs unboxed)

# typeJudge
  * dependent types
  * resolve polytypes (using classOverloads + default decls)

# parser
  * indented 'where', esp. class
  * linefolds
  * GADT style
  * let-rec (?)
  * source locations

# Prelude / dependent types
  * fold-build
  * fusion across functions ? composition fusion
  * var-arity
  * effects

# LFVM
  * Module level constraints ? to avoid name clashes
  * track non-copyable data lifetime
    * data passed to multiple functions:
      if only one wants to modify it: give it ownership and execute last
    * sudoku example - inplace modifications, that undo as stack unravels

# General
  * error message clarity

# Maybe
  * View patterns (?)
  * GuardedRhs
